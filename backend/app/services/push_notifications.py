import json
import logging
import base64
import httpx
from typing import Optional, Dict, Any
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.backends import default_backend
from jwt import encode as jwt_encode
from datetime import datetime, timedelta, timezone
import os

from ..db.session import get_db
from ..db.models.user import User
from ..db.models.push_subscription import PushSubscription

logger = logging.getLogger(__name__)

class PushNotificationService:
    def __init__(self):
        self.vapid_private_key = os.getenv('VAPID_PRIVATE_KEY', '')
        self.vapid_public_key = os.getenv('VAPID_PUBLIC_KEY', '')
        self.vapid_subject = os.getenv('VAPID_SUBJECT', 'mailto:admin@example.com')
        
    async def send_notification(self, user_id: int, title: str, body: str, data: Optional[Dict[str, Any]] = None) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ push-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é"""
        try:
            logger.info(f"–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {title}")
            
            # –ü–æ–ª—É—á–∞–µ–º –ø–æ–¥–ø–∏—Å–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            with next(get_db()) as db:
                subscription = db.query(PushSubscription).filter(
                    PushSubscription.user_id == user_id
                ).first()
                
                if not subscription:
                    logger.warning(f"–ü–æ–¥–ø–∏—Å–∫–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
                    return False
                
                logger.info(f"–ù–∞–π–¥–µ–Ω–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: endpoint={subscription.endpoint[:50]}...")
                
                subscription_info = {
                    'endpoint': subscription.endpoint,
                    'keys': {
                        'p256dh': subscription.p256dh_key,
                        'auth': subscription.auth_key
                    }
                }
            
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º payload
            payload = {
                'title': title,
                'body': body,
                'icon': '/icons/icon-192x192.png',
                'badge': '/icons/icon-72x72.png',
                'tag': 'notification',
                'requireInteraction': False,
                'data': data or {}
            }
            
            # –ü—Ä–æ–±—É–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–µ—Ç–æ–¥–æ–≤ –æ—Ç–ø—Ä–∞–≤–∫–∏
            success = False
            
            # –ú–µ—Ç–æ–¥ 1: –ü—Ä—è–º–æ–π HTTP –∑–∞–ø—Ä–æ—Å –∫ FCM
            if subscription_info['endpoint'].startswith('https://fcm.googleapis.com'):
                success = await self._send_via_fcm_http(subscription_info, payload)
                if success:
                    logger.info("–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —á–µ—Ä–µ–∑ FCM HTTP")
                    return True
            
            # –ú–µ—Ç–æ–¥ 2: pywebpush (—Ä–µ–∑–µ—Ä–≤–Ω—ã–π)
            success = await self._send_via_pywebpush(subscription_info, payload)
            if success:
                logger.info("–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —á–µ—Ä–µ–∑ pywebpush")
                return True
            
            logger.error("–í—Å–µ –º–µ—Ç–æ–¥—ã –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –Ω–µ —É–¥–∞–ª–∏—Å—å")
            return False
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}", exc_info=True)
            return False
    
    async def _send_via_fcm_http(self, subscription_info: Dict, payload: Dict) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —á–µ—Ä–µ–∑ –ø—Ä—è–º–æ–π HTTP –∑–∞–ø—Ä–æ—Å –∫ FCM"""
        try:
            # –ò–∑–≤–ª–µ–∫–∞–µ–º FCM token –∏–∑ endpoint
            endpoint = subscription_info['endpoint']
            if not endpoint.startswith('https://fcm.googleapis.com/fcm/send/'):
                return False
                
            fcm_token = endpoint.replace('https://fcm.googleapis.com/fcm/send/', '')
            
            # –°–æ–∑–¥–∞–µ–º VAPID —Ç–æ–∫–µ–Ω
            vapid_token = self._create_vapid_token(endpoint)
            if not vapid_token:
                logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å VAPID —Ç–æ–∫–µ–Ω")
                return False
            
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º headers
            headers = {
                'Authorization': f'vapid t={vapid_token}, k={self.vapid_public_key}',
                'Content-Type': 'application/json',
                'TTL': '86400'
            }
            
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º FCM payload
            fcm_payload = {
                'to': fcm_token,
                'notification': {
                    'title': payload['title'],
                    'body': payload['body'],
                    'icon': payload['icon'],
                    'badge': payload['badge'],
                    'tag': payload['tag']
                },
                'data': payload.get('data', {})
            }
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    'https://fcm.googleapis.com/fcm/send',
                    json=fcm_payload,
                    headers=headers,
                    timeout=30.0
                )
                
                if response.status_code == 200:
                    logger.info(f"FCM HTTP –æ—Ç–≤–µ—Ç: {response.status_code}")
                    return True
                else:
                    logger.error(f"FCM HTTP –æ—à–∏–±–∫–∞: {response.status_code}, {response.text}")
                    return False
                    
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ FCM HTTP –æ—Ç–ø—Ä–∞–≤–∫–∏: {e}", exc_info=True)
            return False
    
    async def _send_via_pywebpush(self, subscription_info: Dict, payload: Dict) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —á–µ—Ä–µ–∑ pywebpush (—Ä–µ–∑–µ—Ä–≤–Ω—ã–π –º–µ—Ç–æ–¥)"""
        try:
            from pywebpush import webpush, WebPushException
            
            logger.info("–ü–æ–ø—ã—Ç–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —á–µ—Ä–µ–∑ pywebpush")
            
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º VAPID claims
            vapid_claims = {
                "sub": self.vapid_subject
            }
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
            response = webpush(
                subscription_info=subscription_info,
                data=json.dumps(payload),
                vapid_private_key=self.vapid_private_key,
                vapid_claims=vapid_claims
            )
            
            logger.info(f"pywebpush –æ—Ç–≤–µ—Ç: {response}")
            return True
            
        except WebPushException as e:
            logger.error(f"WebPushException: {e}", exc_info=True)
            return False
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ pywebpush –æ—Ç–ø—Ä–∞–≤–∫–∏: {e}", exc_info=True)
            return False
    
    def _create_vapid_token(self, audience: str) -> Optional[str]:
        """–°–æ–∑–¥–∞–Ω–∏–µ VAPID JWT —Ç–æ–∫–µ–Ω–∞"""
        try:
            if not self.vapid_private_key:
                logger.error("VAPID private key –Ω–µ –∑–∞–¥–∞–Ω")
                return None
            
            # –û—á–∏—â–∞–µ–º –∫–ª—é—á –æ—Ç —ç–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
            clean_key = self.vapid_private_key.replace('\\n', '\n')
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á
            try:
                private_key = serialization.load_pem_private_key(
                    clean_key.encode(),
                    password=None,
                    backend=default_backend()
                )
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ VAPID –∫–ª—é—á–∞: {e}")
                return None
            
            # –°–æ–∑–¥–∞–µ–º claims
            now = datetime.now(timezone.utc)
            claims = {
                'aud': audience,
                'exp': int((now + timedelta(hours=12)).timestamp()),
                'sub': self.vapid_subject
            }
            
            # –°–æ–∑–¥–∞–µ–º JWT —Ç–æ–∫–µ–Ω
            token = jwt_encode(
                claims,
                private_key,
                algorithm='ES256'
            )
            
            return token
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è VAPID —Ç–æ–∫–µ–Ω–∞: {e}", exc_info=True)
            return None
    
    async def send_test_notification(self, user_id: int) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"""
        return await self.send_notification(
            user_id=user_id,
            title="üß™ –¢–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ",
            body="–°–∏—Å—Ç–µ–º–∞ push-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ!",
            data={'test': True}
        )

# Singleton instance
push_service = PushNotificationService() 